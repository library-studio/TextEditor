
增加右鼠标键上下文菜单。提供基本的 copy paste cut selectAll 命令

~~~
SafeCut() 功能
如果 Cut 涉及到的范围包含头标区内容，这一段移走内容后，头标区中还要剩下等长的空格字符。头标区
以外的范围的内容则正常移走。

SafePaste() 功能
如果 Paste 进入涉及到目标块的范围包含头标区内容，这一段内容会被从剪贴板中来源的内容对应的部分
替换。来源的其余部分正常替换目标块中其余部分
(注: 目标块是指 Paste 之前记录内容中已经定义为块的部分。这部分需要被来自剪贴板的源内容替换)
1) 想象这样一种场景：Paste 之前记录内容中已经存在一个 23~25 一共三个字符的块。
现在剪贴板中有 1 个字符的内容。Paste 之后，目标 23 位置的字符被来自剪贴板的内容替换，
24~25 两个字符被删除。
3) Paste 之前记录内容中已经存在一个 22~24 一共三个字符的块。
现在剪贴板中有 1 个字符的内容。Paste 之后，目标 22 位置的字符被来自剪贴板的内容替换，
23 位置被填充为空格字符(这里是为了确保头标区足够 24 字符，这也是所谓“安全”的意思 -- 
不破坏头标区内容原有字符数)，24 位置一个被删除。也就是说，即便内容发生缩短，也要保证头标区
不缩短。
粘贴过程可以理解为模拟一次删除块，然后一个一个输入字符。

~~~

实现左侧 Label 区域。

实现拖动鼠标改变 Label 区域宽度功能。

~~~
改变宽度 Relayout() 后，文字内容后面多了一个回车(已修正)

~~~
在头标区内容中间位置回车，自动填入的空格字符，最好能用特殊字符或者颜色显示。
MARC 编辑器中的所有西文空格字符最好都是这样特殊显示。避免操作者看不清内容后方的空格字符。

~~~
提供可以订制背景显示的 delegate 接口
目前能想到的就是绘制字段边框，提供边框线宽等尺寸参数的具体接口

~~~
2025/11/25
bool ReadOnly
显示为灰色，不可编辑，但可以定义块和复制到剪贴板

重构了关于 Paint 文字前景色，背景色的部分代码

~~~
要在 MarcSample 中实现一个菜单命令，可以自由指定文字块的背景色前景色。其中有一项“默认”表示使用 SystemColors 里面的颜色

~~~
字段名字体，要么允许用等宽字体。要么给 Line 增加可以等距显示普通字体的模式

~~~
SplitSubfield() 函数拖慢了速度。要考虑用零拷贝的方式实现。一种方法是切割产生一个 int 集合，
避免直接复制字符串内容。

~~~
试验 DoubleBuffer 效果。

~~~
倒三角字符显示略靠上位置。要设法降低位置。

~~~
(解决)
在字段内容位置输入的时候，左侧字段名和字段指示符位置既然没有变化就不应该刷新闪动。

~~~
(解决)
在字段内容和字段指示符中间的空隙位置点击鼠标，应该从中线位置两侧分别导向命中两者区域，而不应该像现在这样都导向字段指示符区域了。

~~~
调整提示文字区宽度的竖线上的光标形状，要改为中间带有两道竖线的那种，以便和框架窗口边框的 SizeWE 形状相区别

~~~
左侧提示文字区白色不干净底色修正

~~~
左侧提示文字的文字色应该比正常编辑文字的颜色淡一点

~~~
MarcSample 要能保存提示文字区的宽度，下次启动自动恢复原状
MarcSample 要能保存所设置的 MARC 编辑器文档宽度。为自动，手动设置两种状态。
MarcSample 状态行显示块选择变化的坐标信息
要有能显示历史动作集合的界面，方便调试

~~~
Indicator 区域在故意输入两个子字段符号时，会明显溢出显示。
需要考虑一种获得区域实际 Rectangle 的函数。能得知实际溢出的位置情况。
因为 Align Center 的风格缘故，有可能向左或者向右溢出。

~~~
(已改进。为 IBox 增加了 GetRegion() 接口)
多语种的 Range 之间文字方向不同，定义块的时候 Invalidate() 算法不应该简单判断左右关系。

~~~
状态行显示当前插入符所在的字符的内码。文字方向。在整个 MARC 内容中的 offs。
特定的字符，例如英文空格，汉字空格等等，还会提示明确的字符名称。

~~~
选定一段文字块，然后有一个菜单命令可以查看这一段文字的内码。解释 Unicode 信息，Range 文字方向等等。

Dump 每一层的 Record Field (Name Indicator Content) Paragraph Line Range 树状结构。

~~~
FieldProperty 中应该增加定义字段名和字段指示符边框厚度的参数

~~~
GetRegion() 得到的复杂 Region 目前没有包含字段尾部的代表字段结束符的部分。

~~~
在一个字段的内容区域输入字符，刷新范围过大的问题。
在最后输入的时候，应该只刷新这一行的右侧部分。或者只刷新这一行。
在中间行输入的时候，应该只刷新这一行的右侧部分加上后面的行。
如果对一个 Range 中精确刷新右侧以右吃不准，可以观察一下这个 Range 是否复杂 script，
如果是，则整个 Range 都刷新。

~~~
键盘快速输入的时候，ReplaceText() 得到的 update_rect 和 scroll_rect 可以考虑
积攒起来延迟进行 Invalidate() 刷新。

~~~
插入符在字段名或字段指示符上，按 Delete 键，作用应该是删除当前字段。
不过这个行为建议可以用参数定义。可以选择是删空当前字符，还是删除字段。

~~~
MarcControl 可以提供一个默认的右键上下文菜单。上下文菜单应该可以被编程替换。
设计时要考虑，对于所有默认的菜单命令，二次开发者应该也可以通过调用控件函数库中特定的 public 函数自行实现。

~~~
(已经实现)
根据键盘输入速度，超过阈值则自动启用延迟刷新功能。

~~~
当前焦点字段。有查看当前焦点字段的属性。
用虚线框住突出显示。

~~~
鼠标点左侧字段名区可以选中一个或多个字段。Shift 或 Ctrl 复选。


~~~
        protected override void OnMouseWheel(MouseEventArgs e)
        {
            DocumentOrgY += e.Delta;    // * this.Font.Height;

            base.OnMouseWheel(e);
        }

~~~

要有 record field 两级 DOM 对象。操作这些对象就直接控制了 MARC 内容
的变化，并且视觉显示立即兑现。

~~~
丢弃的 MarcField 对象，最好在丢弃前设置一个成员表示它已经被丢弃。
对于 DomField 对象来说，被丢弃后可以读，但不应被修改


~~~
(已实现)
字段名和指示符应该允许单独指定 FixedFont

~~~
头标区 001 字段应该显示为等宽字体。应允许配置。

100$a 等定长子字段允许显示为等宽字体。这个难度较高，涉及到 Paragraph 中如何
为跨过 Line 的若干 Range 建立语义关联，表示它是属于同一个子字段。初步考虑
可以使用 Range.Tag 中一种数据结构来表示属于哪一个子字段。

~~~
今天遇到一个关于字体 Dispose() 引起的问题费了好长时间才解决。
_fixedSizeFont 字体被 Dispose() 掉了之后，整个 IBox 树还存在，
里面的 Range 持有已经 Dispose() 的 Font 对象指针，再进行 OnPaint()
的时候就会抛出异常。
这涉及到 Range 里面的 Font 的生命周期管理问题。原则上 Range 是引用这些
Font 对象的，并不拥有它们的生命周期。所以，当 MarcControl 在 Dispose()
这些 Font 的时候，要抢在下一轮 OnPaint() 触发之前，把整个 IBox 树更新。
方法也很简单，_record.Clear() 然后 ReplaceText() 即可。

这里还思考了一个问题。假设 IBox 树还保留，用 ReplaceText() 重新建立，
可能会只重建其中一部分节点，而不是全部节点。不如彻底清除 IBox 树再重建。
假设非要在 ReplaceText() 里面重建部分节点，那么就要考虑不能利用以前持有
的 Font 对象指针，要(用 GetFont callback function)重新获取 Font 对象指针。
或者 IBox 还需要一个专门的接口用于更新 Font 对象指针。但这个接口单独
做，因为重新获取 Font 可能导致 Paragraph 中 Line 的分行发生变化，所以
不可能无法保持原来的树结构，需要重建。那这个接口就等于是 ReplaceText() 了。

~~~
(已实现)
提供一个 virtual 函数，执行命令键功能。比如 Ctrl+C Ctrl+V Ctrl+X Ctrl+A 等等。

子菜单和命令菜单的功能也可以通过上述 virtual 函数实现?

~~~
CaretMoved 事件可能会被处理程序拖慢。
一个解决办法就是把事件触发放到一个延迟队列中，等空闲时再触发。

~~~
重设字体时窗口内容变空了。
重设字体后，左侧 FixedSizeFont 字体为啥比内容区的 Font 字体还要小?

~~~
当文字块完整包含了一个或者多个字段，也就是说删除不会造成字段名和指示符的不完整，
就应该 SoftlyCut() 和键盘 Delete 键完整删除块。
判断这种情况的算法是: 观察 start 是否处在字段名和指示符的敏感区以内，end 是否处在字段名
和指示符的敏感区以内。如果都不是，则可以 RawCut() 删除。
还有一个原则就是，看删除后原本内容区的是否会跑到敏感区里面来。如果不会跑进来就可以删除。

~~~
有表示左侧提示文字区宽度的 public 成员，便于宿主保存这个宽度。

~~~
表示字段末尾的虚拟块，可以实现为真的显示一个特殊字符。应当可以设置，是否显示这个特殊字符。
(注意，虽然显示这个字符，但无论是键盘方向键移动，还是鼠标左键点击，都没法到达这个
特殊字符的右侧位置。所以这叫“虚拟”。相比起来，真实的字符是可以到达它右侧的)

~~~
"连续的字段"用英文怎么说？

推荐的常见翻译有三种，取决于语境：
•	"consecutive fields" — 强调按顺序连续出现的字段（常用于算法/逻辑描述）。
•	"adjacent fields" — 强调紧邻的字段，通常指相邻两个或几个字段。
•	"contiguous fields" — 强调在内存或布局上没有间隙的连续性，偏技术/低层次表述。
建议：在 MARC/记录处理的业务上下文用 "consecutive fields"；若只是指两个相邻字段可用 "adjacent fields"；需要强调物理/内存连续性时用 "contiguous fields"。

~~~
左侧提示区点选，可以将若干连续的完整的子字段定义为块
Shift 或 Control 点选方法是每次新得到一个字段的 offs range，和以前积累的 block range
进行 Union 或者 Exclude 运算。
一个问题是，目前整个 MarcControl 只有一个 Selection Range，如何表示多个不连续的块呢？
(长期严肃建议：引入一个新的数据结构，比如 List<Range>，用于存储多个不连续的块范围。这样可以在左侧提示区点选时，将每次选中的字段范围添加到这个列表中。Shift 点选时，可以将新选中的范围与列表中的最后一个范围进行 Union 运算；Control 点选时，可以将新选中的范围与列表中的已有范围进行 Exclude 运算。这样就能灵活地管理多个不连续的块选择。)
简单解决的办法是，限制只能一个 Range，因此 Shift 点选和 Ctrl 点选都是同一个效果。
先记载下最开始点的字段 start index，按住 Ctrl 不要放开，然后不管任何点选，都是在修改
end index。假设现有 1~2，点了 3 就变成 1~3，点了 5 就是 1~5。再点 3 就是回到 1~3。
还有一个问题就是 end index 小于 start index 怎么理解。
3~2 理解为等于 2~3。
假设一开始的 start index 是 3。按住 Ctrl 以后点 5，就是 3~5；点 3 就是 3~3；
点 2 就是 3~2，点 1 就是 3~1。
放开 Ctrl 键以后，把得到的 global offs range 兑现到 BlockStart 和 Block End，
中途记忆 start index 和 end index 的参数就丢失了。

然后重新按下 Ctrl，这开始第一次点，和以前遗留的 block range 什么关系？
一个算法是，把 block start end，重新折算为 field index range。只是这个 index
range 中哪个是 start index 哪个是 end index 就不好说了，因为原先记忆已经丢失，
可以简单把小的一个当作 start index。然后开始新一轮点选，在原有基础上修饰。

~~~
其实 field.Paint() 可以有个参数指定完整的这一个 MarcField 全部都是选中状态，
不管 start~end 了。可以考虑用一个特殊数值来表达，比如 -2~-2 之类。
这样可以支持完整的一个一个 MarcField 离散选择。但缺点是仍不支持任意文本离散选择，
比方说同一个 MarcField 内的文本离散选择。这样改造成本收益不划算，还不如将来彻底改为
offs range list 表达。

~~~
MarcField 的 HitTest() 要能处理左侧提示区点击。Area 要能表达左侧

~~~
(已经实现)
在最下面一个 MarcField 之下的空白区域点击，要当作 caret 到了最后一个字段
结束符的后面。这样可以允许文字块选择包含最后一个字段结束符，以便进行(带着结束符的)复制粘贴(和切掉整个字段)等操作

键盘方向键上下移动应该可以到达最后一个字段更后面位置。

(TODO)可以考虑当插入符处在这个特殊位置的时候，临时显示出字段名和指示符区。如果插入符移动离开，
则这一显示自动消失。

~~~
(已经实现)
Ctrl 按下之后不要放开，使用键盘方向键，应为和鼠标点选提示区一样的多选字段效果。

~~~
MarcControl.Content get 的时候，自动为不足的字段名和指示符添加空格字符?
或者用一个专用 Getxxx() 函数实现。单独再有一个可以补齐的函数。一个检查是否有缺乏字段情况
的检查函数。

MarcControl 的派生类要方便自定义回车添加新字段的行为，比如希望新创建的字段
一开始就有完整的字段名和指示符。

(解决)
注意从一个位置回车折断以后，插入符左侧和右侧的字符数可能不足 5 个，要在后面填齐。(这时插入符依然在折断处)

~~~
Caret 形状根据插入和覆盖状态有所不同。覆盖时 Caret 应该是当前字符的宽度。
插入时可以考虑为字符宽度的一般或者四分之一之类。
或者高度根据情况半高或者全高。

~~~
要考虑 MarcControl.cs 和 MarcRecord.cs 之间的分工，函数应该放到哪个文件。

~~~
(未采纳)
其实只要在可能导致字符不足的区域输入完后自动执行一个检查和补足的函数就可以了。
需要注意的是这个检查过程要尽可能快速，避免影响字符输入速度。


~~~
所有字段的最右侧的连续空格显示为 _

~~~
(已实现属性对话框)
PopupMenu 中有菜单命令可以改变 PadWhileInserting

~~~
设计一个列表，存储字段名加子字段名(例如200$a)，表示需要特殊显示的子字段或字段字体和
背景色。可以用于标识有错误的内容。可以定义整个字段，也可以定义子字段。
添加(删除)定义的时候，需要自动 update 相关字段子字段的显示区域。更新函数可以设计成有个
参数决定是否立即更新。如果不立即更新，调主可以稍后用 .Invalidate() 更新窗口全部内容。
如果只想定义字体和背景色中的一种，可以把另外一种指定为 Transparent 颜色。
列表事项中可以包含定义字体和背景色的成员。也可以不指定，然后默认整个控件的两个成员表示
的颜色。这两个成员也应该提供接口可以修改定制。

整个这套机制是用回调函数实现。这意味着也可以由派生类完全控制。可以考虑用虚函数实现上述机制。

~~~
TestDOM 中测试 ReplaceText() 的案例还要充实才行。这是最重要的功能了。

~~~
在字段名中定义一个文字块，然后用键盘输入一个字符，这个字符会替代文字块，可能会造成
被替换部分长度变短，把后面的内容拉进来。
输入字符处理的代码应该改为用 SoftlyRemoveBlock()。但是不是所有情况都这样做，还需要调查一下


~~~
                PaintBack = (o, hdc, rect, clipRect) =>
                {
                    var field = o as MarcField;
                    if (o == null)
                        return;
                    rect.Width = this.AutoScrollMinSize.Width;
                    using (var g = (Graphics.FromHdc((IntPtr)(HDC)hdc)))
                    using (var brush = new SolidBrush(_fieldProperty.SolidColor))
                    {
                        /*
                        var line_height = field.IsHeader ? 0 : Line.GetLineHeight();
                        var solid_height = rect.Height - line_height;
                        if (solid_height > 0)
                        {
                            var solid_rect = new Rectangle(
                            rect.X,
                            rect.Y + line_height,
                            _fieldProperty.NameBorderX + _fieldProperty.NamePixelWidth + _fieldProperty.IndicatorPixelWidth,
                            solid_height);
                            if (clipRect.IntersectsWith(solid_rect))
                                g.FillRectangle(brush, solid_rect);
                        }
                        */

                        field.PaintBackAndBorder(g, rect.X, rect.Y);

                        /*
                        if (field.IsHeader == false)
                        {
                            PaintBackAndBorder(g,
                                rect.X + _fieldProperty.NameBorderX,
                                rect.Y,
                                _fieldProperty.NamePixelWidth,
                                Line.GetLineHeight());
                            if (field.IsControlField == false)
                                PaintBackAndBorder(g,
            rect.X + _fieldProperty.IndicatorBorderX,
            rect.Y,
            _fieldProperty.IndicatorPixelWidth,
            Line.GetLineHeight());
                        }
                        */
                    }
                    /*
                        MarcField.PaintBack(hdc,
                            rect,
                            clipRect,
                            Color.Yellow);
                    */
                },
