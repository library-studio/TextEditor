
增加右鼠标键上下文菜单。提供基本的 copy paste cut selectAll 命令

~~~
SafeCut() 功能
如果 Cut 涉及到的范围包含头标区内容，这一段移走内容后，头标区中还要剩下等长的空格字符。头标区
以外的范围的内容则正常移走。

SafePaste() 功能
如果 Paste 进入涉及到目标块的范围包含头标区内容，这一段内容会被从剪贴板中来源的内容对应的部分
替换。来源的其余部分正常替换目标块中其余部分
(注: 目标块是指 Paste 之前记录内容中已经定义为块的部分。这部分需要被来自剪贴板的源内容替换)
1) 想象这样一种场景：Paste 之前记录内容中已经存在一个 23~25 一共三个字符的块。
现在剪贴板中有 1 个字符的内容。Paste 之后，目标 23 位置的字符被来自剪贴板的内容替换，
24~25 两个字符被删除。
3) Paste 之前记录内容中已经存在一个 22~24 一共三个字符的块。
现在剪贴板中有 1 个字符的内容。Paste 之后，目标 22 位置的字符被来自剪贴板的内容替换，
23 位置被填充为空格字符(这里是为了确保头标区足够 24 字符，这也是所谓“安全”的意思 -- 
不破坏头标区内容原有字符数)，24 位置一个被删除。也就是说，即便内容发生缩短，也要保证头标区
不缩短。
粘贴过程可以理解为模拟一次删除块，然后一个一个输入字符。

~~~

实现左侧 Label 区域。

实现拖动鼠标改变 Label 区域宽度功能。

~~~
改变宽度 Relayout() 后，文字内容后面多了一个回车(已修正)

~~~
在头标区内容中间位置回车，自动填入的空格字符，最好能用特殊字符或者颜色显示。
MARC 编辑器中的所有西文空格字符最好都是这样特殊显示。避免操作者看不清内容后方的空格字符。

~~~
提供可以订制背景显示的 delegate 接口
目前能想到的就是绘制字段边框，提供边框线宽等尺寸参数的具体接口

~~~
2025/11/25
bool ReadOnly
显示为灰色，不可编辑，但可以定义块和复制到剪贴板

重构了关于 Paint 文字前景色，背景色的部分代码

~~~
要在 MarcSample 中实现一个菜单命令，可以自由指定文字块的背景色前景色。其中有一项“默认”表示使用 SystemColors 里面的颜色

~~~
字段名字体，要么允许用等宽字体。要么给 Line 增加可以等距显示普通字体的模式

~~~
SplitSubfield() 函数拖慢了速度。要考虑用零拷贝的方式实现。一种方法是切割产生一个 int 集合，
避免直接复制字符串内容。

~~~
试验 DoubleBuffer 效果。

~~~
倒三角字符显示略靠上位置。要设法降低位置。

~~~
(解决)
在字段内容位置输入的时候，左侧字段名和字段指示符位置既然没有变化就不应该刷新闪动。

~~~
(解决)
在字段内容和字段指示符中间的空隙位置点击鼠标，应该从中线位置两侧分别导向命中两者区域，而不应该像现在这样都导向字段指示符区域了。

~~~
调整提示文字区宽度的竖线上的光标形状，要改为中间带有两道竖线的那种，以便和框架窗口边框的 SizeWE 形状相区别

~~~
左侧提示文字区白色不干净底色修正

~~~
左侧提示文字的文字色应该比正常编辑文字的颜色淡一点

~~~
MarcSample 要能保存提示文字区的宽度，下次启动自动恢复原状
MarcSample 要能保存所设置的 MARC 编辑器文档宽度。为自动，手动设置两种状态。
MarcSample 状态行显示块选择变化的坐标信息
要有能显示历史动作集合的界面，方便调试

~~~
Indicator 区域在故意输入两个子字段符号时，会明显溢出显示。
需要考虑一种获得区域实际 Rectangle 的函数。能得知实际溢出的位置情况。
因为 Align Center 的风格缘故，有可能向左或者向右溢出。

~~~
(已改进。为 IBox 增加了 GetRegion() 接口)
多语种的 Range 之间文字方向不同，定义块的时候 Invalidate() 算法不应该简单判断左右关系。

~~~
状态行显示当前插入符所在的字符的内码。文字方向。在整个 MARC 内容中的 offs。
特定的字符，例如英文空格，汉字空格等等，还会提示明确的字符名称。

~~~
选定一段文字块，然后有一个菜单命令可以查看这一段文字的内码。解释 Unicode 信息，Range 文字方向等等。

Dump 每一层的 Record Field (Name Indicator Content) Paragraph Line Range 树状结构。

~~~
FieldProperty 中应该增加定义字段名和字段指示符边框厚度的参数

~~~
GetRegion() 得到的复杂 Region 目前没有包含字段尾部的代表字段结束符的部分。

~~~
在一个字段的内容区域输入字符，刷新范围过大的问题。
在最后输入的时候，应该只刷新这一行的右侧部分。或者只刷新这一行。
在中间行输入的时候，应该只刷新这一行的右侧部分加上后面的行。
如果对一个 Range 中精确刷新右侧以右吃不准，可以观察一下这个 Range 是否复杂 script，
如果是，则整个 Range 都刷新。

~~~
键盘快速输入的时候，ReplaceText() 得到的 update_rect 和 scroll_rect 可以考虑
积攒起来延迟进行 Invalidate() 刷新。

~~~
插入符在字段名或字段指示符上，按 Delete 键，作用应该是删除当前字段。
不过这个行为建议可以用参数定义。可以选择是删空当前字符，还是删除字段。

~~~
MarcControl 可以提供一个默认的右键上下文菜单。上下文菜单应该可以被编程替换。
设计时要考虑，对于所有默认的菜单命令，二次开发者应该也可以通过调用控件函数库中特定的 public 函数自行实现。

~~~
(已经实现)
根据键盘输入速度，超过阈值则自动启用延迟刷新功能。

~~~
当前焦点字段。有查看当前焦点字段的属性。
用虚线框住突出显示。

~~~
鼠标点左侧字段名区可以选中一个或多个字段。Shift 或 Ctrl 复选。


~~~
        protected override void OnMouseWheel(MouseEventArgs e)
        {
            DocumentOrgY += e.Delta;    // * this.Font.Height;

            base.OnMouseWheel(e);
        }

~~~

要有 record field 两级 DOM 对象。操作这些对象就直接控制了 MARC 内容
的变化，并且视觉显示立即兑现。

~~~
丢弃的 MarcField 对象，最好在丢弃前设置一个成员表示它已经被丢弃。
对于 DomField 对象来说，被丢弃后可以读，但不应被修改


~~~
(已实现)
字段名和指示符应该允许单独指定 FixedFont

~~~
头标区 001 字段应该显示为等宽字体。应允许配置。

100$a 等定长子字段允许显示为等宽字体。这个难度较高，涉及到 Paragraph 中如何
为跨过 Line 的若干 Range 建立语义关联，表示它是属于同一个子字段。初步考虑
可以使用 Range.Tag 中一种数据结构来表示属于哪一个子字段。

~~~
今天遇到一个关于字体 Dispose() 引起的问题费了好长时间才解决。
_fixedSizeFont 字体被 Dispose() 掉了之后，整个 IBox 树还存在，
里面的 Range 持有已经 Dispose() 的 Font 对象指针，再进行 OnPaint()
的时候就会抛出异常。
这涉及到 Range 里面的 Font 的生命周期管理问题。原则上 Range 是引用这些
Font 对象的，并不拥有它们的生命周期。所以，当 MarcControl 在 Dispose()
这些 Font 的时候，要抢在下一轮 OnPaint() 触发之前，把整个 IBox 树更新。
方法也很简单，_record.Clear() 然后 ReplaceText() 即可。

这里还思考了一个问题。假设 IBox 树还保留，用 ReplaceText() 重新建立，
可能会只重建其中一部分节点，而不是全部节点。不如彻底清除 IBox 树再重建。
假设非要在 ReplaceText() 里面重建部分节点，那么就要考虑不能利用以前持有
的 Font 对象指针，要(用 GetFont callback function)重新获取 Font 对象指针。
或者 IBox 还需要一个专门的接口用于更新 Font 对象指针。但这个接口单独
做，因为重新获取 Font 可能导致 Paragraph 中 Line 的分行发生变化，所以
不可能无法保持原来的树结构，需要重建。那这个接口就等于是 ReplaceText() 了。

~~~
(已实现)
提供一个 virtual 函数，执行命令键功能。比如 Ctrl+C Ctrl+V Ctrl+X Ctrl+A 等等。

子菜单和命令菜单的功能也可以通过上述 virtual 函数实现?

~~~
CaretMoved 事件可能会被处理程序拖慢。
一个解决办法就是把事件触发放到一个延迟队列中，等空闲时再触发。

~~~
重设字体时窗口内容变空了。
重设字体后，左侧 FixedSizeFont 字体为啥比内容区的 Font 字体还要小?

~~~
当文字块完整包含了一个或者多个字段，也就是说删除不会造成字段名和指示符的不完整，
就应该 SoftlyCut() 和键盘 Delete 键完整删除块。
判断这种情况的算法是: 观察 start 是否处在字段名和指示符的敏感区以内，end 是否处在字段名
和指示符的敏感区以内。如果都不是，则可以 RawCut() 删除。
还有一个原则就是，看删除后原本内容区的是否会跑到敏感区里面来。如果不会跑进来就可以删除。

~~~
有表示左侧提示文字区宽度的 public 成员，便于宿主保存这个宽度。

~~~
表示字段末尾的虚拟块，可以实现为真的显示一个特殊字符。应当可以设置，是否显示这个特殊字符。
(注意，虽然显示这个字符，但无论是键盘方向键移动，还是鼠标左键点击，都没法到达这个
特殊字符的右侧位置。所以这叫“虚拟”。相比起来，真实的字符是可以到达它右侧的)

~~~
"连续的字段"用英文怎么说？

推荐的常见翻译有三种，取决于语境：
•	"consecutive fields" — 强调按顺序连续出现的字段（常用于算法/逻辑描述）。
•	"adjacent fields" — 强调紧邻的字段，通常指相邻两个或几个字段。
•	"contiguous fields" — 强调在内存或布局上没有间隙的连续性，偏技术/低层次表述。
建议：在 MARC/记录处理的业务上下文用 "consecutive fields"；若只是指两个相邻字段可用 "adjacent fields"；需要强调物理/内存连续性时用 "contiguous fields"。

~~~
左侧提示区点选，可以将若干连续的完整的子字段定义为块
Shift 或 Control 点选方法是每次新得到一个字段的 offs range，和以前积累的 block range
进行 Union 或者 Exclude 运算。
一个问题是，目前整个 MarcControl 只有一个 Selection Range，如何表示多个不连续的块呢？
(长期严肃建议：引入一个新的数据结构，比如 List<Range>，用于存储多个不连续的块范围。这样可以在左侧提示区点选时，将每次选中的字段范围添加到这个列表中。Shift 点选时，可以将新选中的范围与列表中的最后一个范围进行 Union 运算；Control 点选时，可以将新选中的范围与列表中的已有范围进行 Exclude 运算。这样就能灵活地管理多个不连续的块选择。)
简单解决的办法是，限制只能一个 Range，因此 Shift 点选和 Ctrl 点选都是同一个效果。
先记载下最开始点的字段 start index，按住 Ctrl 不要放开，然后不管任何点选，都是在修改
end index。假设现有 1~2，点了 3 就变成 1~3，点了 5 就是 1~5。再点 3 就是回到 1~3。
还有一个问题就是 end index 小于 start index 怎么理解。
3~2 理解为等于 2~3。
假设一开始的 start index 是 3。按住 Ctrl 以后点 5，就是 3~5；点 3 就是 3~3；
点 2 就是 3~2，点 1 就是 3~1。
放开 Ctrl 键以后，把得到的 global offs range 兑现到 BlockStart 和 Block End，
中途记忆 start index 和 end index 的参数就丢失了。

然后重新按下 Ctrl，这开始第一次点，和以前遗留的 block range 什么关系？
一个算法是，把 block start end，重新折算为 field index range。只是这个 index
range 中哪个是 start index 哪个是 end index 就不好说了，因为原先记忆已经丢失，
可以简单把小的一个当作 start index。然后开始新一轮点选，在原有基础上修饰。

~~~
其实 field.Paint() 可以有个参数指定完整的这一个 MarcField 全部都是选中状态，
不管 start~end 了。可以考虑用一个特殊数值来表达，比如 -2~-2 之类。
这样可以支持完整的一个一个 MarcField 离散选择。但缺点是仍不支持任意文本离散选择，
比方说同一个 MarcField 内的文本离散选择。这样改造成本收益不划算，还不如将来彻底改为
offs range list 表达。

~~~
MarcField 的 HitTest() 要能处理左侧提示区点击。Area 要能表达左侧

~~~
(已经实现)
在最下面一个 MarcField 之下的空白区域点击，要当作 caret 到了最后一个字段
结束符的后面。这样可以允许文字块选择包含最后一个字段结束符，以便进行(带着结束符的)复制粘贴(和切掉整个字段)等操作

键盘方向键上下移动应该可以到达最后一个字段更后面位置。

(TODO)可以考虑当插入符处在这个特殊位置的时候，临时显示出字段名和指示符区。如果插入符移动离开，
则这一显示自动消失。

~~~
(已经实现)
Ctrl 按下之后不要放开，使用键盘方向键，应为和鼠标点选提示区一样的多选字段效果。

~~~
MarcControl.Content get 的时候，自动为不足的字段名和指示符添加空格字符?
或者用一个专用 Getxxx() 函数实现。单独再有一个可以补齐的函数。一个检查是否有缺乏字段情况
的检查函数。

MarcControl 的派生类要方便自定义回车添加新字段的行为，比如希望新创建的字段
一开始就有完整的字段名和指示符。

(解决)
注意从一个位置回车折断以后，插入符左侧和右侧的字符数可能不足 5 个，要在后面填齐。(这时插入符依然在折断处)

~~~
Caret 形状根据插入和覆盖状态有所不同。覆盖时 Caret 应该是当前字符的宽度。
插入时可以考虑为字符宽度的一半或者四分之一之类。
或者高度根据情况半高或者全高。

~~~
要考虑 MarcControl.cs 和 MarcRecord.cs 之间的分工，函数应该放到哪个文件。

~~~
(未采纳)
其实只要在可能导致字符不足的区域输入完后自动执行一个检查和补足的函数就可以了。
需要注意的是这个检查过程要尽可能快速，避免影响字符输入速度。


~~~
所有字段的最右侧的连续空格显示为 _

~~~
(已实现属性对话框)
PopupMenu 中有菜单命令可以改变 PadWhileEditing

~~~
设计一个列表，存储字段名加子字段名(例如200$a)，表示需要特殊显示的子字段或字段字体和
背景色。可以用于标识有错误的内容。可以定义整个字段，也可以定义子字段。
添加(删除)定义的时候，需要自动 update 相关字段子字段的显示区域。更新函数可以设计成有个
参数决定是否立即更新。如果不立即更新，调主可以稍后用 .Invalidate() 更新窗口全部内容。
如果只想定义字体和背景色中的一种，可以把另外一种指定为 Transparent 颜色。
列表事项中可以包含定义字体和背景色的成员。也可以不指定，然后默认整个控件的两个成员表示
的颜色。这两个成员也应该提供接口可以修改定制。

整个这套机制是用回调函数实现。这意味着也可以由派生类完全控制。可以考虑用虚函数实现上述机制。

~~~
TestDOM 中测试 ReplaceText() 的案例还要充实才行。这是最重要的功能了。

~~~
(已解决)
在字段名中定义一个文字块，然后用键盘输入一个字符，这个字符会替代文字块，可能会造成
被替换部分长度变短，把后面的内容拉进来。
输入字符处理的代码应该改为用 SoftlyRemoveBlock()。但是不是所有情况都这样做，还需要调查一下


~~~
                PaintBack = (o, hdc, rect, clipRect) =>
                {
                    var field = o as MarcField;
                    if (o == null)
                        return;
                    rect.Width = this.AutoScrollMinSize.Width;
                    using (var g = (Graphics.FromHdc((IntPtr)(HDC)hdc)))
                    using (var brush = new SolidBrush(_fieldProperty.SolidColor))
                    {
                        /*
                        var line_height = field.IsHeader ? 0 : Line.GetLineHeight();
                        var solid_height = rect.Height - line_height;
                        if (solid_height > 0)
                        {
                            var solid_rect = new Rectangle(
                            rect.X,
                            rect.Y + line_height,
                            _fieldProperty.NameBorderX + _fieldProperty.NamePixelWidth + _fieldProperty.IndicatorPixelWidth,
                            solid_height);
                            if (clipRect.IntersectsWith(solid_rect))
                                g.FillRectangle(brush, solid_rect);
                        }
                        */

                        field.PaintBackAndBorder(g, rect.X, rect.Y);

                        /*
                        if (field.IsHeader == false)
                        {
                            PaintBackAndBorder(g,
                                rect.X + _fieldProperty.NameBorderX,
                                rect.Y,
                                _fieldProperty.NamePixelWidth,
                                Line.GetLineHeight());
                            if (field.IsControlField == false)
                                PaintBackAndBorder(g,
            rect.X + _fieldProperty.IndicatorBorderX,
            rect.Y,
            _fieldProperty.IndicatorPixelWidth,
            Line.GetLineHeight());
                        }
                        */
                    }
                    /*
                        MarcField.PaintBack(hdc,
                            rect,
                            clipRect,
                            Color.Yellow);
                    */
                },


~~~
(已解决)
当 Font 改变时，Caret 的高度和宽度都会改变，需要重新创建一下，立即兑现显示。
一开始编辑器刚打开时也要兑现 Caret 正确的高度和宽度。

当 Font 改变后，要重新 MoveCaret() 一次。

~~~
字段名区域背景要有几个基本的风格，可以选择配置使用。
一、有 solid 背景色，有 textbox 边框
二、没有 solid 背景色，有 textbox 边框
三、没有 solid 背景色，没有边框
四、textbox 下沿有虚线，其它什么也没有(也就是说边框可以选择几种不同的样式)

总之来说，solid 背景色是否具有，和边框是否显示，可以自由组合。那恐怕就是独立参数控制较好。
可以单独实现为一个 SolidAreaStyle 类，来组合定义这些特性。

当然，允许二次开发者彻底自绘，则是另外一种更高级的定制法。将来可以做成插件
允许用户自己安装。

~~~
(已完成)
双击鼠标左键可以定义当前子字段为一个文字块。多次双击，可以在“定义子字段内容为块”
和“定义整个子字段(包括子字段名)为块”之间切换。

Ctrl+左右方向键。定义当时 caret 位置的子字段为块，并将 caret 移动到块的右侧。这
样可以连续定义一个一个“部分”为连续的块，相当于 caret 跳着走。(或者只走不定义块
也是一种效果)

~~~
(目前仅做到标识字段)
_caretInfo.ChildIndex 所在的字段，要显示为 focused 样式。
可以考虑为，当 caret 处在字段名或指示符区域上的时候，这个区域显示 focused 包围
矩形，当 caret 处在字段内容区域的时候，仅在所在 Line 上显示 focused 包围矩形。

~~~
(已解决)
整个 Document 高度应该包含最后一行 caret 可达的位置，不然 caret 移动到
那里之后，可能会看不到。

(尚未解决)
(同理，Document 右侧应该为 ReturnWidth 留出空间，避免某行最右一个字符还往右
的回车换行符号看不见)

~~~
(已解决)
当 _lastX 为一个较大值时上下方向键移动 caret，当到达最后一行，然后再向上的时候，
不应该在字段名第一字符位置，而应该在 _lastX 位置。

~~~
(已解决)
左侧鼠标拖动定义字段为块时，要随着位置变化 EnsureCaretVisible() 确保插入符始终可见

~~~
实现键盘 ScrollLock 状态功能。移动插入符要始终保持 Caret 在可视区正中(通过自动卷滚)。

~~~
Insert 键插入一个新字段?

~~~
在字段名和指示符位置删除。要么不要被保护填充，允许删除完一个字段全部内容。
要么专门把 Delete 键改为删除字段用途。
Delete 键删除字段的功能，激进一点的做法是不弹出对话框提示。因为有 Undo 功能可以随时撤销，不怕误操作。

~~~
字段名同一位置反复删除，因为填充的缘故，形成没有实质性改变的 history 动作。
可以考虑对连续执行的无实质性改变的 history 动作去重不进入历史队列。

~~~
(已经实现)
用中间点的字符代替空格显示。这种能力要做成一个可配置参数。

(尚未实现，主要是还没有想好用什么显示字符来表示)
汉字空格也要能用替代字符显示，和西文的空格要区别开。

~~~
(已经实现)
Shift+Delete 删除当前子字段
Ctrl+Q  整理字段顺序

Ctrl+I  插入一个子字段符号(并且自动把汉字输入法关闭，便于继续输入字母)。

PageUp PageDown

~~~~
(目前建议在派生类中实现)
获取提示区字符串的内容要缓存到一个 Hashtable 中，避免这里成为速度瓶颈
不过，缓存需要考虑和数据库名，MARC 格式等等环境因素有关，独立分配

~~~
(已确认)
Home 和 End 后 _lastX 应该变化

~~~
(已经确认)
按需填充不足字符的函数，执行后要维持操作前的 block range 的语义不变。

~~~
(已经实现)
Shift+PageDown 的效果应该是定义文字块，和 Shift+左右方向键效果类似

~~~
(已经实现)
在字段末尾(实际上 offs 位于字段结束符左边)删除，要能定制效果。可以是没有任何动作。

~~~
https://learn.microsoft.com/zh-cn/dotnet/desktop/winforms/high-dpi-support-in-windows-forms

~~~
(已经实现)
当选定了一个文字块以后，在文字块内点鼠标左键，点击和放开之间并没有移动。
这种操作应该理解为取消块定义，把插入符定位到点击的位置。
这就需要检测拖动一个最小距离以后，才会被当作进入拖拽过程。没有移动就放开，并不进入这个过程。

~~~
001 字段，内容的最后一个字符位置开始 backspace，当删除到只剩下 00 时，会自动填充一个空格。
但这个做法是还可以探讨的。是否需要自动填充 三个空格？因为 '00 ' 字段已经不是 Control Field 了，要填满应该是包括指示符区。
不过这样做有点怪异，感觉 backspace 删着删着突然一下字符还多出来了。

~~~
(已实现)
当拖动鼠标越出窗口 Client Area 时，应该触发时钟，每隔一秒钟自动卷滚一段距离，这样可以
提高拖动定义块时候的舒适性。(不然就要来回移动一下鼠标，才能引起卷动)

~~~
Enabled 发生变化时，控件背景色应该发生变化，效果类似 ReadOnly 状态。


~~~
SetContent() 函数内部可以考虑实现一种算法，把新旧两个字符串，从头尾两个方向往中间逼近，寻找两端没有变化
的部分，在调用 ReplaceText() 时只修改中间不同的一段，这样会让编辑历史更简洁。


~~~
(已经解决)
Undo() 以后要 EnsureCaretVisible() 让插入符所在位置卷滚出现到可见位置。

~~~
SetContent() 设置用的字符串，可以考虑简单规定不允许包含记录结束符 29。
也可以允许包含，但比较麻烦的一点时，只允许在最后一个字段的后面存在。并且最后一个字段要具备字段
结束符，不允许没有字段结束符就直接来记录结束符。所以规定干脆不允许出现记录结束符倒也简单。
遇到不合法的内容，直接抛出 ArgumentExeption 即可。这样迫使使用 MarcControl 的一方预先检查
字符串内容是否合法，合法才能调用。
MarcControl 中可以考虑提供两个函数，一个是检查字符串内容是否合法，不合法给出具体报错；另一个
时不但能检查和报错，还能自动修正不合法之处。那这样一来，实际上 MarcControl 自己也具备了兼容
不合法的字符串内容(自动修正和接受)的能力了。

还有一种做法是，如果遇到不合适的位置出现了记录结束符，自动替换为 PaddingChar，或者删除。
但遇到不合法并且自动修正了之后(也就是说不抛出异常)，那么是否返回信息表示这一情况，值得完美主义者考虑一下。

~~~
增加一个函数 GetContent()，允许指定是否自动填充缺乏的字符。

~~~
可以有一种机制，把所有操作历史追加记忆到一个临时文件，文件按照日期编号，每日一个文件。
当发生了数据丢失的时候，可以去这个文件中找以前的编辑历史。

需要考虑增加一个表示完全不同的记录的边界的元素。可以记忆记录最终保存的记录路径之类。

~~~
(已实现)
颜色主题的首次定制，在切换到 [定制] 之前的那个 Theme 的内容作为定制的初始内容。

~~~
复制到 Windows 剪贴板中的特殊格式，要在不同的应用之间可以互相识别
可以考虑用 JSON 文本。里面设置一个标志性内容，便于判断

~~~
当光标到达分割条上方时，分割条要亮起来。光标移走以后，再自动恢复不显眼的状态。

~~~
为了测试 Clipboard.SetText() 偶尔抛出 System.Runtime.InteropServices.ExternalException
异常(所请求的剪贴板操作失败)的问题是否得到解决，需要编写一段故意频繁
密集访问 Clipboard 的代码，用来进行测试验证。

发生未捕获的界面线程异常:
Type: System.Runtime.InteropServices.ExternalException
Message: 所请求的剪贴板操作失败。
Stack:
在 System.Windows.Forms.Clipboard.ThrowIfFailed(Int32 hr)
在 System.Windows.Forms.Clipboard.SetDataObject(Object data, Boolean copy, Int32 retryTimes, Int32 retryDelay)
在 System.Windows.Forms.Clipboard.SetText(String text, TextDataFormat format)
在 LibraryStudio.Forms.MarcControl.Copy()
在 LibraryStudio.Forms.MarcControl.<KeyTriggerCommand>g__Trigger|295_0(CommandItem item)
在 LibraryStudio.Forms.MarcControl.KeyTriggerCommand(Keys keyData)
在 LibraryStudio.Forms.MarcControl.ProcessCmdKey(Message& msg, Keys keyData)
在 System.Windows.Forms.Control.PreProcessMessage(Message& msg)
在 System.Windows.Forms.Control.PreProcessControlMessageInternal(Control target, Message& msg)
在 System.Windows.Forms.Application.ThreadContext.PreTranslateMessage(MSG& msg)

~~~
字段名提示文字可增加一种新风格，放在字段名上方作为单独的一行显示。默认字体的字号可以设置小一些。

~~~
(已经实现)
视觉风格对话框要增加对三种字体的独立设置功能。
字体名 TextBox 本身也要使用相应的字体

~~~
(已经解决)
字段名和指示符区域的宽度应该按照 FixedSizeFont 的平均宽度来计算。而不是按照内容字体。
注意两类字体的字号可能完全不同。

~~~
(已经实现)
字体配置界面应该有设置为默认字体的按钮。可以三个按钮。

(尚未实现)
另外可以有字体主题的 ComboBox 列表供选用。但字体大小需要另外给一个列表，每次都统一修改
三个字体的大小。

字体定义的 JSON 代码可以复制粘贴。

~~~
(已经解决)
视觉风格对话框打开后如果没有任何修改，确定按钮应该发灰。即便这时点确定按钮可以关闭对话框，
那对话框关闭以后也不应该感觉到 MarcControl 画面抖动了一下。

~~~
Shift+左右方向键定义文字块，在阿拉伯文上偶尔有字符显示空心的问题。

斜体字体，在 Block Region 失效的时候，每个 Range 左右要略大一点范围，不然会留下残影。

~~~
01317nam0 2200277   450 22222$$d= Основний курс української мови$$hⅠ Частина$$dОсновной курс украинского языка$$hⅠ Частина01317nam0 2200277   450 00101201808143100520180814925326.0010  a978-7-02-014453-2dCNY42.00100  a20181221d2018    cemy0chiy50      ea1011 achiceng102  aCNb110000105  aa   z   000ay106  ar2001 a哈利·波特与魔法石Aha li· bo te yu mo fa shif(英)J.K.罗琳著g苏农译205  a2版输入中文测试文字位置     0شلاؤيثبفaلاؤيثبلاهتنمةىenglish test 345210  a北京c人民文学出版社d2018.10215  a241页c图d24cm330  a本书讲述：哈利·波特的人生中没有魔法。他和一点都不友善的德思礼夫妇，还有他们令人厌恶的儿子达力住在一起。哈利的房间是一个窄小的储物间，就在楼梯下面，而且十一年来他从未有过生日派对。 但是有一天，猫头鹰信使突然送来一封神秘的信件，令人不敢相信的是，信里附着一张来自霍格沃茨魔法学校的录取哈利入学的通知书。 哈利于九月一日带着他的猫头鹰乘着特快列车来到魔法学校。在学校里，他遇到了他一生中两个最好的朋友，体验了骑着飞天扫帚打球的运动，从课堂上和生活中的所有事物里学到了魔法。不仅如此，他还得知自己将有一个伟大而不可思议的命运……333  a本书为儿童读物5101 aHarry Potter and the philosopher's stonezeng6060 a儿童小说x长篇小说y英国z现代111690  aI561.84v511111111111111111111111a11中文701 0c(英)a罗琳Aluo linc(Rowling, J. K)4著702 0a苏农Asu nong4译801 0aCNb百万庄c20181221

~~~
在从右向左书写顺序的 Range 下方显示波浪线，表明其特殊性

~~~
context.ClearFontCache() 可以适当延长时间再清除。
有几个情况下是必须立即清除。1) 字体改变。2) 发现包含的句柄数量超过一个阈值。

~~~
自动发生各种字符进行测试，观察字体不能支持显示的情况。

~~~
using (var cache = new SafeSCRIPT_CACHE()) 用法速度慢


~~~
用海量 MARC 机内格式数据不断装入 MarcControl，观察对其中不具备字形的 char 的替代显示情况，观察内存和 GDI 句柄使用情况，验证没有内存泄漏和句柄泄漏。

~~~
(已经实现)
安全删除块的时候，如果出现了一个块定义，头部是一个字段结束符，尾部是一个字段的最后一个字符，那么可以认为可以全部删除，
不用保留任何字符。
也可以理解为头部字符不删除，从第二个字符开始一直删除到最后一个字符外加多删除一个字段结束符。不过这种删除方法，进入编辑历史
的信息发生了一点不同，当 Undo 的时候操作者会感到诧异。另外这样删除以后插入符的位置也会靠后一个字符。(未采纳)


~~~
研究一下 SCRIPT_CACHE 的正确用法。是否直接用 NULL 即可。

~~~
Tab 键从当前子字段跳到下一个子字段。Shift+Tab 键从当前子字段跳到上一个子字段。


~~~
原有的 MarcRecord.MoveByOffs() 代码:

        // 根据 Caret Offs 进行移动
        // 注: 偏移位置中有一些位置是具有多个可用位置的情况。比如 Paragraph 中
        // 下一行的开头等同于上一行的末尾，为了获得其中期望的一个可用位置，可善用
        // direction 参数值，direction
        // 小于 0 表示这是从后向前移动，如果遇到后方可用的位置优先使用后方的；direction
        // 大于 0 表表示这是从前向后的移动，如果遇到靠前的可用位置优先使用靠前的。
        // 而如果 direction 为零，则无法表达取舍倾向性。比如 offs:1 direction:0。如果确有倾向性要求，
        // 以倾向靠后的可用位置为例，上例可以改为以 offs:2 direction:-1 调用。
        // parameters:
        //      offs    插入符在当前对象中的偏移
        //      direction   -1 向左 0 原地 1 向右
        // return:
        //      -1  越过左边
        //      0   成功
        //      1   越过右边
        public int MoveByOffs(int offs_param,
            int direction,
            out HitInfo info)
        {
            info = new HitInfo();

            var infos = new List<HitInfo>();

            int offs = 0;
            MarcField field = null;
            int start_y = 0;
            for (int i = 0; i < _fields.Count; i++)
            {
                // info.RangeIndex = 0;
                field = _fields[i] as MarcField;
                // TODO: 改为使用 .FullTextLength
                var line_text_length = field.PureTextLength;
                var return_length = i == 0 ? 0 : 1;
                var text_length = line_text_length + return_length;
                if (offs_param + direction >= offs && offs_param + direction < offs + text_length)
                {
                    var ret = field.MoveByOffs(offs_param - offs,
                        direction,
                        out HitInfo hit_info);
                    if (ret == 0)
                    {
                        Debug.Assert(ret == 0);

                        var temp_info = new HitInfo
                        {
                            X = hit_info.X,
                            Y = hit_info.Y + start_y,
                            Area = hit_info.Area,
                            ChildIndex = i,
                            TextIndex = hit_info.Offs,
                            Offs = offs + hit_info.Offs,
                            LineHeight = hit_info.LineHeight,
                            InnerHitInfo = hit_info,
                        };

                        if (direction >= 0)
                        {
                            info = temp_info;
                            return 0;
                        }
                        // 暂时不返回，继续匹配后面可能匹配的位置
                        infos.Add(temp_info);
                    }
                }
                else
                {
                    // 如果早先发生过匹配，则表明此时发生不匹配以后，再往后不可能发生匹配了，
                    // 于是及时返回，避免多余的后继匹配操作
                    if (infos.Count > 0)
                    {
                        info = infos[infos.Count - 1];
                        return 0;
                    }
                }

                offs += text_length;
                start_y += field.GetPixelHeight();
            }

            if (offs == offs_param + direction)
            {
                if (_fields.Count > 0)
                {
                    // 最后一个字段的结束符右侧
                    var last_field = _fields.Last();
                    // 找最后一个字段的第一个字符的 caret 位置
                    var ret = last_field.MoveByOffs(0,
        0,
        out HitInfo hit_info);
                    if (ret == 0)
                    {
                        // 头标区得到的 x 在 content 区，要调整到 name 区
                        if (this._fields.Count == 1)
                            hit_info.X = _fieldProperty.NameX;

                        var temp_info = new HitInfo
                        {
                            X = hit_info.X,
                            Y = hit_info.Y + start_y,
                            Area = hit_info.Area,
                            ChildIndex = _fields.Count,
                            TextIndex = hit_info.Offs,
                            Offs = offs + hit_info.Offs,
                            LineHeight = hit_info.LineHeight,
                            InnerHitInfo = hit_info,
                        };
                        info = temp_info;
                        return 0;
                    }
                }
                else
                {
                    // 连头标区都没有
                    info = new HitInfo
                    {
                        X = _fieldProperty.NameX,
                        Y = 0 + start_y,
                        Area = Area.BottomBlank,
                        ChildIndex = _fields.Count,
                        TextIndex = 0,
                        Offs = offs,
                        LineHeight = FontContext.DefaultFontHeight,
                        InnerHitInfo = null,
                    };
                    return 0;
                }
            }

            if (infos.Count > 0)
            {
                info = infos[infos.Count - 1];
                return 0;
            }

            // 没有任何 MarcField 的情况
            if (_fields.Count == 0
                && offs + direction == 0)
            {
                info.X = 0;
                info.Y = 0;
                info.ChildIndex = 0;
                info.Offs = offs + direction;
                info.TextIndex = 0;
                info.Area = Area.Text;
                info.LineHeight = 0;    //  Line.GetLineHeight();
                return 0;
            }

            // TODO: 定位到尽量靠后的一个 marcfield 末尾
            info.Area = Area.BottomBlank;
            return 1;
        }

        ~~~~
                void PaintHilightText(
            IContext context,
            SafeHDC hdc,
            int x,
            int y,
            Line line,
            int line_height,
            int[] indices,
            Rectangle block_rect,
            Rectangle clipRect)
        {
            foreach (var index in line.piVisualToLogical)   // piVisualToLogical
            {
                var range = line.Ranges[index];

                Font used_font = range.Font;
                IntPtr font_handle = context.GetFontHandle(range.Font);

                int iReserved = 0;

                /*
                // Range 的主体矩形。斜体情况可能会有部分笔画伸出这个矩形之外
                Rectangle item_rect = new Rectangle(
                    x + range.Left,
                    y,
                    range.PixelWidth,   // (int)(pABC.abcA + pABC.abcB + pABC.abcC);
                    line_height);

                // Range 的外围包围矩形。可能比 item_rect 宽度更大(比如斜体情况)
                // 用于判断 Clip 交叉
                var item_bounds = AdjustRect(item_rect,
                    range,
                    true,
                    true);
                */

                //var font_handle = used_font.ToHfont();
                try
                {
                    // using (var cache = new SafeSCRIPT_CACHE())
                    var cache = new SafeSCRIPT_CACHE();
                    using (var dc_context = hdc.SelectObject(font_handle))
                    {
                        /*
                        //testing
                        DrawSolidRectangle(hdc,
block_rect,
Color.Green,
clipRect);
                        */

                        // var highlight_text_color = context?.GetForeColor?.Invoke(range, true) ?? SystemColors.HighlightText;
                        var highlight_text_color = range.ColorCache
                            .GetForeColor(
                            context?.GetForeColor,
                            range,
                            true);
                        var old_color = Gdi32.SetTextColor(hdc, new COLORREF(highlight_text_color));
                        var old_mode = Gdi32.SetBkMode(hdc, Gdi32.BackgroundMode.TRANSPARENT); // 设置背景模式为透明
                        try
                        {
                            var ret = ScriptTextOut(hdc,
            cache,
            x + range.Left,
            y + range.Y,    // y + _line_height - (int)GetAscentPixel(used_font),
            (int)Gdi32.ETO.ETO_CLIPPED, // | (int)Gdi32.ETO.ETO_OPAQUE,
            Intersect(block_rect, clipRect),   // [In, Optional] PRECT lprc,
            range.a,  // line.Item.a, // in SCRIPT_ANALYSIS psa,
            range.DisplayText,  // range.Text,  //  [Optional, MarshalAs(UnmanagedType.LPWStr)] string ? pwcReserved,
            iReserved,  //  [Optional] int iReserved,
            range.glfs,   // [In, MarshalAs(UnmanagedType.LPArray)] ushort[] pwGlyphs, 
            range.glfs.Length,    // int cGlyphs,
            range.advances,  // [In, MarshalAs(UnmanagedType.LPArray)] int[] piAdvance,
            null,   // [In, Optional, MarshalAs(UnmanagedType.LPArray)] int[] ? piJustify,
            range.pGoffset[0]); // in GOFFSET pGoffset); 
                            ret.ThrowIfFailed();
                        }
                        finally
                        {
                            Gdi32.SetBkMode(hdc, old_mode);
                            Gdi32.SetTextColor(hdc, old_color); // 恢复文本颜色
                        }
                    }
                }
                finally
                {
                    // Gdi32.DeleteFont(font_handle);
                }
            }
        }

~~~
MarcSample 中状态行显示批处理进度。

~~~
MarcSubfield 结构设计的时候，有两种可能的方法。一种是用一个 Paragraph 实现，这样子字段名字符就是一个普通的部分；
另外一种是用一个 Line 和一个 Paragraph 实现，这样子字段名字符就是一个单独的 Line。
后者还有一个特点是子字段内容可以靠右显示，把子字段符号部分让出来向左悬挂，这样看起来比较清晰。
不过将来也可以考虑给 Paramgraph 增加一种首行悬挂显示的功能，这样只用一个 Paragraph 也可以实现类似的效果。

~~~
Template 定长模板的结构设计。有两种可能的方法。
第一种是用若干个 Line 对象实现，每个占据一行。
第二种是用一个 Paragraph 对象实现，里面有若干个 Line 对象，每个 Line 对象占据一行。也就是说把原先 Paragraph 的折行算法
变成按照模板定义来进行折行。
考虑到模板每一行左侧还需要有提示文字，右侧还有可能的注释文字，所以第一种方法灵活一些。
但第二种方法的优点是，类似块定义等等机制，实现起来比较简单，利用原来 Paragraph 的函数即可。

注意现实中，可能需要编辑的数据短于或者长于模板定义规定的总长度，需要允许这两种情况发生，并且不破坏数据。
长于的情况可以都堆积到最后一个多出来的存储非法内容的 Line 里面。


~~~
鼠标点头标区最后一个字符以右，然后 Ctrl+下方向键，无法向下移动插入符定义字段为文字块

~~~
在每个子字段的 Paragraph 中上下移动方向键，处理不正确。

~~~
MarcSubfield 左端应该也有 Caption 区域，Splitter 区域，Button 区域。

~~~
展开、收缩按钮用普通文字显示即可。
˃˅


~~~
Template 中使用 Line 还是 Paragraph 可以思考一下

~~~
查询对象结构的时候，要先准备好一个对象，才能进行查询。但查询通常是为了新创建对象才进行的，查询时
对象还可能不存在，或者状态即将被改变。所以查询接口应该设计成利用一种字符串参数提供信息进行查询，
而不是利用对象作为参数。
可以考虑用一种类似路径的字符串。上级对象的类型和名字通常可以从父对象得知，或者显而易见。
本级对象的类型和名字需要专门提供。

例如子字段对象，应该是子字段容器对象里面有预先准备好的结构信息。子字段对象只要到容器对象处查询即可。
子字段对象无论如何翻天覆地变化，都不可能改变容器对象里面的结构信息。这些结构信息一直适用。
因为容器是属于字段对象的。字段名无论如何不可能因为子字段的改变而发生改变。

这就要求容器对象里面能预先准备好带有树状递归结构的定义，比如某个子字段包括其下级的 Chars 的定义，这个定义的
存储体积还是挺大的。


~~~
caption 区域的宽度，要分级存储。修改一个级别的宽度，其它级的宽度不变。
