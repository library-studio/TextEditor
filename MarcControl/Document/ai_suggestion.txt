深呼吸一下，然后分步回答。

结论（优先级建议）
- 首选：U+FFFD REPLACEMENT CHARACTER（字符：�）——标准、跨平台、语义明确，操作系统/工具链通常也用它表示“无法解码/缺失字形”。  
- 备选：U+25A1 WHITE SQUARE / U+25A0 BLACK SQUARE（□/■）或字体“tofu”空心方框 —— 在视觉上更醒目，便于快速定位。  
- 空白类（仅针对空格不可显示）：U+2423 OPEN BOX（␣）或 U+00B7 MIDDLE DOT（·）。（但空格可视化建议与正文“渲染层替换”分开处理）

理由（要点）
- 语义：U+FFFD 是 Unicode 定义用于替换不可表示字符的标准码位，用户、开发者和调试工具都能理解。  
- 可见性：白方块/实心方块比 U+FFFD 更醒目，但可能破坏阅读体验。  
- 不破坏数据：请在“渲染/绘制”层替代显示，而不要把替代字符写回文本（避免改变复制、搜索、语义）。

实作建议（与当前代码库匹配）
1. 在遇到 ScriptShape/ShapeAndPlace 检测到缺失字形时，不要直接把替换字符插入文本；改为在绘制阶段绘制替代符号（U+FFFD 或方框）。这与项目中多处注释（“显示为替代字符” / 抛异常处）语义一致且更安全。  
2. 绘制细节：用与正文相同字号的字体，但用可配置颜色（如浅红或灰框），并在鼠标悬停时显示 tooltip（U+XXXX / 字形信息）。  
3. 可配置化：提供用户选项（替代符号：U+FFFD / □ / · / 不显示；颜色；仅缺失字形显示 vs 所有不可见字符显示）。  
4. 优先尝试字体回退：在 ShapeAndPlace 中先用字体组逐个尝试；若全部失败，再采取“绘制替代符”策略。

示例：在 `TextControl\Line.cs` 中添加一个小工具函数（只负责返回推荐替代字符串），并在 ShapeAndPlace 无法找到字形时用它在绘制层显示（不改文本）：

```csharp
csharp TextControl\Line.cs
// 在 Line 类中添加（靠近类开头的辅助常量/方法）
static class Replacement
{
    // 推荐：U+FFFD REPLACEMENT CHARACTER
    public const string Default = "\uFFFD";

    // 备用：方块或中点
    public const string WhiteBox = "\u25A1"; // □
    public const string MiddleDot = "\u00B7"; // ·
}
```

说明如何使用（实现步骤，不直接改写文本）：
- 在 `ShapeAndPlace` 检测到所有候选字体都产生空字形（当前代码通过 glfs==0 或 partial_fonts 判断）且最终要“抛异常”的分支，不再抛出；而是记录该 range 需要“绘制替代符”标记（比如 `range.DisplayText = Replacement.Default; range.Font = fallbackFont;` 或在绘制时检测 `range.HasMissingGlyphs`）。  
- 在 `Line.Paint` / `Range.Paint` 绘制文字前，若标记了“缺失字形”，使用 GDI 绘制 `Replacement.Default`（或用户配置的符号），并且可用不同颜色或边框强调。  
- 同时为调试和可访问性，在 `Range.ColorCache` 或 tooltip 回调中提供缺失信息（U+XXXX, 代码点），便于用户识别问题来源。

额外建议（用户体验）
- 默认把替代符颜色设为半透明或浅灰，避免破坏阅读。  
- 提供“显示不可见/替换字符”开关（默认关或默认只显示在不可显示字形处）。  
- 在状态行或悬浮提示中显示缺失字形的 Unicode 码点和候选字体信息，方便修正字体配置。

需要我做什么？
- 如果你愿意，我可以给出一个完整的补丁片段（在 `ShapeAndPlace` 的抛异常处改为标记并在 `Paint` 中绘制替代符），并遵循项目风格把可配置项放到 `IContext`/`FontContext` 中。要我生成补丁吗？

~~~

错误（简述）
托管调试助手报出 `FatalExecutionEngineError`，在 `ShapeAndPlace` 中执行 `sva = new SCRIPT_VISATTR[max];` 时触发——这通常意味着 CLR 堆已被本地（非托管）代码破坏，而不是简单的托管空引用或普通异常。

为什么会发生（<200 字）
在同一函数刚刚对 `glfs` 和 `log` 进行了本机交互相关的分配并随即调用 `ScriptShape`。`FatalExecutionEngineError` 几乎总是由非托管/互操作引发的内存损坏导致。最可能的根本原因是传入 Uniscribe 的缓冲区或句柄参数与 Uniscribe 实际写入期望不匹配，从而在本机层写越界并破坏 CLR 堆。证据与可疑点：

- 本函数使用 `max = (int)Math.Round(str.Length * 1.5m + 16)`，随后分配 `glfs = new ushort[max]`，但把 `log = new ushort[str.Length]`。若 Uniscribe 写入 `pwLogClust`（log）时按 glyph 数或按 `cMaxGlyphs` 索引，会越界（glyph 数可能 > 字符数），导致堆损坏——而分配 `sva` 时才被检测出来并崩溃。
- `SafeSCRIPT_CACHE` 的创建/使用不当也可能导致本机写入非法内存（如果未正确初始化/传递），但从调用序列看首要嫌疑是数组长度/边界不匹配。
- 其它风险：在 DC 上选择/释放 HFONT 的时机错误（在未先撤换出 DC 的情况下 DeleteObject），或对 P/Invoke 签名/marshal 不匹配，都会导致类似崩溃。

具体且可立即验证的修复（优先级高）
1) 把 `log` 的长度从 `str.Length` 改为 `max`，以保证 `ScriptShape` 在任何情况下不会写入超出边界的 `pwLogClust`（最小改法，最有可能立即消除越界写入）：
```csharp
// 原
// log = new ushort[str.Length];
// sva = new SCRIPT_VISATTR[max];
// 改为
log = new ushort[max];
sva = new SCRIPT_VISATTR[max];
```

2) 对 `ScriptShape` 返回的 `c` 做严格检查，再传递给 `ScriptPlace`：
```csharp
var result = ScriptShape(..., glfs, log, sva, out var c);
// 检查 c 的范围
if (c < 0 || c > max)
    throw new InvalidOperationException($"ScriptShape 返回不合理的 glyph 数: {c} (max={max})");
Array.Resize(ref glfs, c);
Array.Resize(ref sva, c);
```

3) 避免不安全的 SafeSCRIPT_CACHE 用法：尽量使用 Vanara/官方包装提供的创建函数或传入 `IntPtr.Zero`（并根据文档处理），不要直接 new 一个未初始化的底层句柄类型。

4) 确保 HFONT 在 DC 中被替换回去后再 DeleteObject；用 `DeleteObject` 而不是自定义 DeleteFont（确认 Vanara API 的正确释放函数），并确保 SelectObject/Dispose 顺序正确（当前代码看起来用 using 包裹 SelectObject，但还是要确认最终 Delete 在 Select 恢复之后执行）。

改进建议（可选）
- 在调用任何 Uniscribe API 前，把所有传入数组按 `cMaxGlyphs` 一致分配并记录其容量；把所有 P/Invoke 返回码做更完整的防御性处理。
- 添加本机交互的单元测试（带极端长/复杂脚本字符串）以重现并验证边界。
- 若使用 Vanara，请优先用其提供的 SafeXXX 工厂/方法，避免手工 new SafeHandle。

Related Work Items
- 无（在远程仓库中未找到相关 issue/工作项）。

结论（一句话）
最可能的根本原因是 Uniscribe 在本机层写入了超出 `log` 缓冲区的内容（glyph vs char 长度不一致），导致堆损坏并在随后分配 `sva` 时触发 `FatalExecutionEngineError`。优先修复：把 `log` 的长度改为 `max`，并在 `ScriptShape` 返回后对 `c` 做边界检查。

**要我把 log 长度改为 max 吗？**
