
https://learn.microsoft.com/en-us/globalization/fonts-layout/fonts
Font fallback
One benefit of Unicode is the ability to represent many languages without additional data specifying script. However, the broad glyph and script support in Unicode is also a problem, since few fonts support more than a few scripts. Indeed, it's difficult to do a good job of making fonts with glyphs for different scripts such that all conform to one set of vertical metrics. To overcome this limitation, and to accommodate complex scripts, most rendering systems (the technology for displaying the font onto the screen) include functionality to detect if the currently selected font doesn't support a particular script and can automatically switch (fall back) to a predefined font that has appropriate glyphs for the desired script. All these operations are transparent to the user.

Here's an example to better understand this mechanism. A user selects the Tahoma font to enter some text first in English, next in Hebrew, and then in Telugu. Tahoma provides support for Latin and Hebrew scripts but doesn't contain any Telugu glyphs. The application or the rendering system detects this lack of font support and automatically renders the Telugu script by using its fallback font. Each application and each operating system can define its own fallback font for any Unicode script range, depending on the technologies used.

The .NET framework supports font fallback via the FontFamily class. There are three options for defining font fallback sequences in .NET:

Specify the fallback sequence in code.
Use the default composite fonts that are specified as standard with the .NET framework installation.
Define your own composite font, using FontFamilyMap to specify the set of Unicode code points, language, and target font family.
For Win32 and Uniscribe, use ScriptShape to determine whether glyphs are supported in a font to implement font fallback.

CSS supports font fallback through the font-family property. You can specify one or more fonts to be used in order of precedence when displaying text. You should always end with one of the generic fonts (serif, sans-serif, monospace, cursive, fantasy) so that the browser is always able to display text if none of the specified fonts is available.

~~~
https://superuser.com/questions/396160/how-to-change-configure-font-fallback
If font linking is enabled on your device, you can examine the registry by enumerating the subkeys of the registry key at HKEY_LOCAL_MACHINE–\SOFTWARE\Microsoft\Windows NT\CurrentVersion\FontLink\SystemLink to determine the mappings of linked fonts to base fonts. You can add links by using Regedit to create additional subkeys. Once you have located the registry key that has just been mentioned, from the Edit menu, Highlight the font face name of the font you want to link to and then from the Edit menu, click Modify. On a new line in the dialog field "Value data" of the Edit Multi-String dialog box, enter the path and file name to link to, and face name of the font. Use coma to separate the font file name and font face name.

计算机\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\FontLink\SystemLink

~~~
http://archives.miloush.net/michkap/archive/2005/10/01/476022.html
Font Linking vs. Font Fallback

~~~
https://shajisoft.com/shajisoft_wp/fontlink-for-cjk-on-english-windows-10/
Fontlink for CJK on English Windows 10

~~~
https://learn.microsoft.com/zh-cn/typography/fonts/windows_10_font_list#arabic-script-supplemental-fonts
Windows 10 Font List - Arabic Script Supplemental Fonts

~~~
https://learn.microsoft.com/zh-cn/typography/font-list/arial-unicode-ms

~~~
https://github.com/MicrosoftDocs/win32/blob/docs/desktop-src/gdiplus/-gdiplus-obtaining-font-metrics-use.md


~~~
https://github.com/fliedonion/WinformsImeControlWithUserControlBasics


https://github.com/ufwt/windows-XP-SP1/blob/d521b6360fcff4294ae6c5651c539f1b9a6cbb49/XPSP1/NT/windows/advcore/ctf/aimm1.2/dimm/imewndhd.cpp#L403

https://github.com/dnobori/DN-Poderosa/blob/34d37f63348a348f5d0a6b6119cd1a5cd1eda339/TerminalEmulator/TerminalControl.cs#L742

~~~
可以考虑为相邻的两个 range 当它们的阅读顺序相反时，在文字底部显示顺序符号。

~~~
斜体的 f 有一部分伸出方框外沿。
一个 Line 的最左边 range 的 .a 和最右边 range 的 .c 要考虑到方框的宽度计算中
刷新显示一个 Range 时，有部分比划可能伸出到方框外面，那么当相邻的 Range 失效时，
应当能引起本 Range 刷新显示。也就是说，这部分伸出去的区域，应当在本 Range 进行范围
检测的时候考虑进去，作为属于本 Range 的一部分区域。(从这个角度，两个 Range 之间的区域是有部分重叠的)

显示每个 Range 的 block 背景颜色区域时间，要考虑将一行的背景区域一次性绘制，而不应一个一个 range 地绘制。
因为一个一个绘制，后一个背景可能覆盖到前一个的字体笔画伸出的部分。

~~~
键入字符通过一个专门的修改 content 的函数实现，这个函数要把 Undo 功能一并实现。

当键盘输入阿拉伯文时，插入符要出现一种向左旗帜的样子。

~~~
https://learn.microsoft.com/en-us/dynamics365/fin-ops-core/dev-itpro/user-interface/bidirectional-support

https://help.oclc.org/Metadata_Services/Connexion/Connexion_client/International_cataloging/Get_started/40Right_to_left_control_characters

https://marijnhaverbeke.nl/blog/cursor-in-bidi-text.html

~~~
Line 里面切割 Range 的时候，需要一个 delegate，可用于定制附加的切割要求。
比如要求在遇到某个特定字符之前进行切割。也就是说，凡是遇到这个字符，即便相邻的其它
字符原本是适合放在同一个 Range 的，也要在这个字符这里强行切开 Range。类似的需求。

~~~
https://symbl.cc/en/unicode-table/#basic-latin

https://github.com/delinx/Fixedsys-Core

https://learn.microsoft.com/en-us/answers/questions/1194439/using-custom-font-inside-c-net-core-application

http://tom7.org/fixedersys/

~~~
键入文字的速度优化。

当 blockOffs1 2 发生变化时，计算出变化前和变化后涉及到的区域，然后只失效这个区域，不要全部 Invalidate()
算法是，记下 offs1 和 offs2 的 HitInfo，用 HitInfo 计算出范围矩形。
还有一种算法，就是把这两个 offs 整数直接作为“失效区”参数传递给 Paint() 函数。Paint() 函数自己可以搞清楚需要刷新的区域。但这种方法要经过 WM_INVALIDATE 消息传递自定义的数据结构恐怕有难度

如果要编写一个函数将 offs1 -- offs2 整数范围变换为失效区 Rectangle，可以考虑用一个
函数一轮遍历解决两个 offs 的转换翻译，提高执行速度

~~~
Seogoe Fluent Icons



~~~
当存在块定义的时候，左方向键是去到块的起始位置，右方向键是去到块的结束位置。

~~~
https://list.winehq.org/pipermail/wine-patches/2016-June/151047.html


~~~
(未采纳)
Line 对象即便没有任何 Range，也要获得一次字体，把字体高度和平均字符宽度等参数准备好。
或者可以这样：任何时候都必须准备至少一个空格字符的 Range，便于获得这些参数。


~~~
字体名的正常顺序

Arial Unicode MS
Aldhabi
Microsoft Sans Serif
PMingLiU
MS PMincho
Batang
Microsoft YaHei UI
Microsoft JhengHei UI
Yu Gothic UI
Malgun Gothic

~~~
GetFont 函数的参数，最佳实践是适当的 IBox 对象。
比如 MarcField 对象中的 _name _indicator _content 子对象，让函数
可以知晓该返回什么字体。
IBox 对象新增了 Parent 成员，可以探知父级对象，进而探知所有祖先对象。
MarcField 对象可以考虑增设一些成员，方便探知字段名。这样可以根据字段名
决定字体。
比如 001 字段的字体探索过程如下：
触发 GetFont 函数的对象是 _content，函数执行的时候，先根据 is Paragraph
可以得知它是 _content。进而用 .Parent 可以得到 MarcField 对象，进而可以
得到字段名 '001'。
这里，利用 is Paragraph 判断，是比较脆弱的做法，可以考虑为所有 IBox 对象
增设一个接口 Name，这样就可以预先为 _content 准备好一个 Name，就方便用来
随时判断对象类型名字了。


~~~
        // parameters:
        //      block_start     选中范围的开始偏移量。
        //                      以当前 line 的左边界为 0
        //                      如果大于本行文字长度，表示未选中本行     
        //      block_end       选中范围的结束偏移量
        //                      以当前 line 的左边界为 0
        //                      如果小于 0，表示未选中本行     
        //      virtual_tail_length 行末虚拟尾部字符个数。如果这个尾部处在选择范围，需要显示为选择背景色
        public void Paint(
            IContext context,
            SafeHDC hdc,
            int x,
            int y,
            Rectangle clipRect,
            int blockOffs1,
            int blockOffs2,
            int virtual_tail_length)
        {
            Line line = this;


            int line_height = this.GetPixelHeight();
            // 代表回车换行符号字符的像素宽度
            // int _average_char_width = Line.GetAverageCharWidth();

            var block_start = Math.Min(blockOffs1, blockOffs2);
            var block_end = Math.Max(blockOffs1, blockOffs2);

            block_start = Math.Max(0, block_start);
            block_end = Math.Min(line.TextLength + virtual_tail_length, block_end);

            //block_start = 0;
            //block_end = 100;

            // 绘制 Range 特定的背景色。指非 highlight 背景色
            foreach (var range in line.Ranges)   // piVisualToLogical
            {
                // 绘制普通背景色
                // 如果 .GetBackColor() 返回 Color.Transparent 则不进行绘制，保持背景透明
                {
                    // var bk_color = context.GetBackColor?.Invoke(range, false) ?? Color.Transparent;
                    var bk_color = range.ColorCache
                        .GetBackColor(context.GetBackColor,
                        range,
                        false);
                    if (bk_color != Color.Transparent)
                    {
                        var rect = GetBlockRect(range,
x + range.Left,
y,
line_height,
0,
range.Text.Length);
                        // var larger = ((Rectangle)(rect)).Larger();
                        if (clipRect.IntersectsWith((Rectangle)rect))
                        {
                            DrawSolidRectangle(hdc,
                            rect,
                            bk_color,
                            clipRect);
                        }
                    }
                }
            }

            // 块的背景矩形数组
            /*
            PRECT[] block_rects = new PRECT[line.Ranges.Count];
            PRECT[] block_bounds = new PRECT[line.Ranges.Count];
            */
            // 每个 range 的矩形
            // Rectangle[] range_rects = new Rectangle[line.Ranges.Count];

            // 块矩形。null 表示不在块内
            Rectangle[] block_rects = new Rectangle[line.Ranges.Count];
            // abc 调整后的块矩形。null 表示不在块内
            Rectangle[] block_abc_rects = new Rectangle[line.Ranges.Count];
            // 块邻接的 range 要参与的 rect。null 表示不是邻接的 range
            Rectangle[] neighbor_rects = new Rectangle[line.Ranges.Count];


            // 块是否包含全部文字的标志
            bool[] full_flags = new bool[line.Ranges.Count];

            // 先绘制行和块背景
            // 以逻辑顺序遍历 Ranges。注意显示位置 x 可能是跳动的
            // 每个 Range 的块背景色不能在分散到每个 Range 的处理中绘制，因为那样可能会擦掉 Range 伸出去的笔画(例如 Italic 风格的 'f')。
            if (block_start != block_end)
            {
                int i = 0;
                int tail_range_index = 0;
                if (line.Ranges.Count > 0 && line.piLogicalToVisual.Length > line.Ranges.Count - 1)
                    tail_range_index = line.piVisualToLogical[line.Ranges.Count - 1];
                foreach (var range in line.Ranges)   // piVisualToLogical
                {
                    var is_tail_in_line = i == tail_range_index;

                    // 绘制选中范围的背景色
                    if (block_start <= range.DisplayText.Length && block_end >= 0)
                    {
                        var tail_in_block = is_tail_in_line
                            && virtual_tail_length > 0
                            && block_start < range.DisplayText.Length + virtual_tail_length
                            && block_end > range.DisplayText.Length;
                        var block_rect = GetBlockRect(range,
                            x + range.Left,
                            y,
                            line_height,
                            block_start,
                            block_end);

                        // 如果当前 range 正巧是视觉上最右边一个 range，那么可以加宽宽度即可。
                        // 但如果不是最右边的，则要另外专门绘制一次最右边的这个代表回车的块
                        if (tail_in_block)
                        {
                            if (i == this.piLogicalToVisual[i])
                                block_rect.Width += FontContext.DefaultReturnWidth;
                            else
                            {
                                PaintReturnSelectedBack(
                                    context,
                                    hdc,
                                    x,
                                    y,
                                    clipRect);
                            }
                        }

                        if (block_rect.Width == 0)
                            goto SKIP;
                        Debug.Assert(block_rect.Width > 0);


                        // var larger = ((Rectangle)(block_rect)).Larger();

                        if (clipRect.IntersectsWith((Rectangle)block_rect))
                        {
                            // var back_color = context?.GetBackColor?.Invoke(range, true) ?? SystemColors.Highlight;
                            var back_color = range.ColorCache
                                .GetBackColor(context?.GetBackColor,
                                range,
                                true);

                            if (back_color != Color.Transparent)
                            {
                                DrawSolidRectangle(hdc,
                                block_rect,
                                back_color,
                                clipRect);
                            }
                        }

                        /*
                        // clipping 矩形的左右进行微调。避免斜体字的某些笔画伸出去的部分被显示成不同的颜色
                        var left_delta = range.pABC.abcA;
                        var right_delta = range.pABC.abcC;
                        if (block_start <= 0 && left_delta < 0)
                            block_rect.left -= -left_delta + 1; // 左侧空白
                        if (block_end >= range.DisplayText.Length && right_delta < 0)
                            block_rect.right += -right_delta + 1; // 右侧空白
                        */
                        /*
                        AdjustRect(ref block_bound,
    range,
    block_start <= 0,
    block_end >= range.DisplayText.Length);
                        */

                        block_rects[i] = block_rect; // 记录块背景矩形

                        {
                            var block_bound = AdjustRect((Rectangle)block_rect,
                                range,
                                true, //block_start <= 0,
                                true/*block_end >= range.DisplayText.Length*/);
                            block_abc_rects[i] = block_bound;
                        }

                        full_flags[i] = (block_start <= 0 && block_end >= range.DisplayText.Length); // 标记本 Range 是否全选

                        // 设置邻接标志
                        if (Utility.InRange(0, block_start, block_end)
                            && i > 0)
                            neighbor_rects[i - 1] = block_rect;
                        if (Utility.InRange(range.TextLength, block_start, block_end)
                            && i < this.Ranges.Count - 1)
                            neighbor_rects[i + 1] = block_rect;

                    }

                SKIP:

                    block_start -= range.DisplayText.Length;
                    block_end -= range.DisplayText.Length;

                    i++;
                }

                // 没有任何 Range 的情况，依然要显示 tail char
                if (i == 0 && virtual_tail_length > 0)
                {
                    // 绘制选中范围的背景色
                    if (block_start <= 0 && block_end >= virtual_tail_length)
                    {
                        /*
                        var block_rect = new PRECT(x, y,
                            x + FontContext.DefaultReturnWidth,
                            y + line_height);
                        */
                        var block_rect = new Rectangle(x,
                            y,
                            FontContext.DefaultReturnWidth,
                            line_height);

                        // var larger = ((Rectangle)(block_rect)).Larger();
                        if (clipRect.IntersectsWith(block_rect))
                        {
                            // var back_color = context?.GetBackColor?.Invoke(null, true) ?? SystemColors.Highlight;
                            var back_color = line.ColorCache
                                .GetBackColor(
                                context?.GetBackColor,
                                null,
                                true);
                            if (back_color != Color.Transparent)
                            {
                                DrawSolidRectangle(hdc,
                                        block_rect,
                                        back_color,
                                        clipRect);
                            }
                        }
                    }
                }
            }

            // 绘制普通文本
            foreach (var index in line.piVisualToLogical)   // piVisualToLogical
            {
                var range = line.Ranges[index];

                if (string.IsNullOrEmpty(range.DisplayText))
                    continue;

                var block_rect = block_rects[index]; // 获取块背景矩形
                var block_bound = block_abc_rects[index];
                var full_block = full_flags[index]; // 获取是否全选标志

                Font used_font = range.Font;
                var cache = new SafeSCRIPT_CACHE();
                int iReserved = 0;

                // Range 的主体矩形。斜体情况可能会有部分笔画伸出这个矩形之外
                Rectangle item_rect = new Rectangle(
                    x + range.Left,
                    y,
                    range.PixelWidth,   // (int)(pABC.abcA + pABC.abcB + pABC.abcC);
                    line_height);

                // Range 的外围包围矩形。可能比 item_rect 宽度更大(比如斜体情况)
                // 用于判断 Clip 交叉
                var item_bounds = AdjustRect(item_rect,
                    range,
                    true,
                    true);

                var font_handle = used_font.ToHfont();
                try
                {
                    using (var dc_context = hdc.SelectObject(font_handle))
                    {
                        // 第一次显示 Range 内全部文字，用 Text Color
                        // 如果是全部属于块，这样的第一次显示正常文字可以省略
                        // (如果是斜体，虽然全部属于块，这里也不能省略)
                        if ((/*full_block == false*/ true || block_rect == null)
                            && clipRect.IntersectsWith((Rectangle)(item_bounds)))
                        {
                            // var text_color = context?.GetForeColor?.Invoke(range, false) ?? SystemColors.WindowText;
                            var text_color = range.ColorCache
                                .GetForeColor(
                                context?.GetForeColor,
                                range,
                                false);

                            var old_color = Gdi32.SetTextColor(hdc, new COLORREF(text_color)); // 设置文本颜色为黑色
                            var old_mode = Gdi32.SetBkMode(hdc, Gdi32.BackgroundMode.TRANSPARENT); // 设置背景模式为透明

                            try
                            {
                                var result = ScriptTextOut(hdc,
                                            cache,
                                            x + range.Left,
                                            y + range.Y,    // y + _line_height - (int)GetAscentPixel(used_font),
                                            (int)Gdi32.ETO.ETO_CLIPPED, // fuOptions,
                                            Intersect(item_bounds, clipRect),   // [In, Optional] PRECT lprc,
                                            range.a,  // line.Item.a, // in SCRIPT_ANALYSIS psa,
                                            range.DisplayText,  // range.Text,  //  [Optional, MarshalAs(UnmanagedType.LPWStr)] string ? pwcReserved,
                                            iReserved,  //  [Optional] int iReserved,
                                            range.glfs,   // [In, MarshalAs(UnmanagedType.LPArray)] ushort[] pwGlyphs, 
                                            range.glfs.Length,    // int cGlyphs,
                                            range.advances,  // [In, MarshalAs(UnmanagedType.LPArray)] int[] piAdvance,
                                            null,   // [In, Optional, MarshalAs(UnmanagedType.LPArray)] int[] ? piJustify,
                                            range.pGoffset[0]); // in GOFFSET pGoffset); 
                                result.ThrowIfFailed();
                            }
                            finally
                            {
                                Gdi32.SetBkMode(hdc, old_mode);
                                Gdi32.SetTextColor(hdc, old_color); // 恢复文本颜色
                            }
                        }

#if REMOVED
                        // 第二次显示块部分文字，用 Highlight Color
                        if (block_rect != null
                            && clipRect.IntersectsWith((Rectangle)(block_bound)))
                        {
                            /*
                            //testing
                            DrawSolidRectangle(hdc,
block_rect,
Color.Green,
clipRect);
                            */

                            // var highlight_text_color = context?.GetForeColor?.Invoke(range, true) ?? SystemColors.HighlightText;
                            var highlight_text_color = range.ColorCache
                                .GetForeColor(
                                context?.GetForeColor,
                                range,
                                true);
                            var old_color = Gdi32.SetTextColor(hdc, new COLORREF(highlight_text_color));
                            var old_mode = Gdi32.SetBkMode(hdc, Gdi32.BackgroundMode.TRANSPARENT); // 设置背景模式为透明
                            /*
                            Gdi32.IntersectClipRect(hdc, block_rect.left + 10,
                                block_rect.top,
                                block_rect.right + 10,
                                block_rect.bottom);
                            */
                            //var old_bk_color = Gdi32.SetBkColor(hdc, new COLORREF((uint)SystemColors.Highlight.ToArgb())); // 设置文本颜色为黑色
                            try
                            {
                                var ret = ScriptTextOut(hdc,
                cache,
                x + range.Left,
                y + range.Y,    // y + _line_height - (int)GetAscentPixel(used_font),
                (int)Gdi32.ETO.ETO_CLIPPED, // | (int)Gdi32.ETO.ETO_OPAQUE,
                Intersect(block_rect, clipRect),   // [In, Optional] PRECT lprc,
                range.a,  // line.Item.a, // in SCRIPT_ANALYSIS psa,
                range.DisplayText,  // range.Text,  //  [Optional, MarshalAs(UnmanagedType.LPWStr)] string ? pwcReserved,
                iReserved,  //  [Optional] int iReserved,
                range.glfs,   // [In, MarshalAs(UnmanagedType.LPArray)] ushort[] pwGlyphs, 
                range.glfs.Length,    // int cGlyphs,
                range.advances,  // [In, MarshalAs(UnmanagedType.LPArray)] int[] piAdvance,
                null,   // [In, Optional, MarshalAs(UnmanagedType.LPArray)] int[] ? piJustify,
                range.pGoffset[0]); // in GOFFSET pGoffset); 
                                ret.ThrowIfFailed();
                            }
                            finally
                            {
                                Gdi32.SetBkMode(hdc, old_mode);
                                Gdi32.SetTextColor(hdc, old_color); // 恢复文本颜色
                                /*
                                var region = Gdi32.CreateRectRgn(clipRect.Left, clipRect.Top, clipRect.Right, clipRect.Bottom);
                                Gdi32.SelectClipRgn(hdc, region);
                                region.Dispose();
                                */
                            }
                        }

#endif
                    }
                    // x_offset += line.PixelWidth;    // pABC.abcA + pABC.abcB + pABC.abcC;
                }
                finally
                {
                    Gdi32.DeleteFont(font_handle);
                }
            }

            // 绘制块内文本
            // 第一步把 rect 拼接起来
            Rectangle line_rect = System.Drawing.Rectangle.Empty;
            foreach (var index in line.piVisualToLogical)   // piVisualToLogical
            {
                var range = line.Ranges[index];

                var block_rect = block_rects[index]; // 获取块背景矩形
                var block_abc_rect = block_abc_rects[index];
                var neightbor_rect = neighbor_rects[index];
                var full_block = full_flags[index]; // 获取是否全选标志

                if (block_rect != null)
                    line_rect = Utility.Union(line_rect, block_rect);
                else if (neightbor_rect != null)
                    line_rect = Utility.Union(line_rect, neightbor_rect);
            }

            foreach (var index in line.piVisualToLogical)   // piVisualToLogical
            {
                var range = line.Ranges[index];

                if (string.IsNullOrEmpty(range.DisplayText))
                    continue;

                var block_rect = block_rects[index]; // 获取块背景矩形
                var block_abc_rect = block_abc_rects[index];
                var neightbor_rect = neighbor_rects[index];
                var full_block = full_flags[index]; // 获取是否全选标志

                Font used_font = range.Font;
                var cache = new SafeSCRIPT_CACHE();
                int iReserved = 0;

                // Range 的主体矩形。斜体情况可能会有部分笔画伸出这个矩形之外
                Rectangle item_rect = new Rectangle(
                    x + range.Left,
                    y,
                    range.PixelWidth,   // (int)(pABC.abcA + pABC.abcB + pABC.abcC);
                    line_height);

                // Range 的外围包围矩形。可能比 item_rect 宽度更大(比如斜体情况)
                // 用于判断 Clip 交叉
                var item_bounds = AdjustRect(item_rect,
                    range,
                    true,
                    true);

                var font_handle = used_font.ToHfont();
                try
                {
                    using (var dc_context = hdc.SelectObject(font_handle))
                    {
                        // 第二次显示块部分文字，用 Highlight Color
                        if ((block_rect != null && clipRect.IntersectsWith(block_rect))
                            || (neightbor_rect != null && clipRect.IntersectsWith(neightbor_rect))
                            )
                        {
                            /*
                            //testing
                            DrawSolidRectangle(hdc,
block_rect,
Color.Green,
clipRect);
                            */

                            // var highlight_text_color = context?.GetForeColor?.Invoke(range, true) ?? SystemColors.HighlightText;
                            var highlight_text_color = range.ColorCache
                                .GetForeColor(
                                context?.GetForeColor,
                                range,
                                true);
                            var old_color = Gdi32.SetTextColor(hdc, new COLORREF(highlight_text_color));
                            var old_mode = Gdi32.SetBkMode(hdc, Gdi32.BackgroundMode.TRANSPARENT); // 设置背景模式为透明
                            /*
                            Gdi32.IntersectClipRect(hdc, block_rect.left + 10,
                                block_rect.top,
                                block_rect.right + 10,
                                block_rect.bottom);
                            */
                            //var old_bk_color = Gdi32.SetBkColor(hdc, new COLORREF((uint)SystemColors.Highlight.ToArgb())); // 设置文本颜色为黑色
                            try
                            {
                                var ret = ScriptTextOut(hdc,
                cache,
                x + range.Left,
                y + range.Y,    // y + _line_height - (int)GetAscentPixel(used_font),
                (int)Gdi32.ETO.ETO_CLIPPED, // | (int)Gdi32.ETO.ETO_OPAQUE,
                Intersect(line_rect, clipRect),   // [In, Optional] PRECT lprc,
                range.a,  // line.Item.a, // in SCRIPT_ANALYSIS psa,
                range.DisplayText,  // range.Text,  //  [Optional, MarshalAs(UnmanagedType.LPWStr)] string ? pwcReserved,
                iReserved,  //  [Optional] int iReserved,
                range.glfs,   // [In, MarshalAs(UnmanagedType.LPArray)] ushort[] pwGlyphs, 
                range.glfs.Length,    // int cGlyphs,
                range.advances,  // [In, MarshalAs(UnmanagedType.LPArray)] int[] piAdvance,
                null,   // [In, Optional, MarshalAs(UnmanagedType.LPArray)] int[] ? piJustify,
                range.pGoffset[0]); // in GOFFSET pGoffset); 
                                ret.ThrowIfFailed();
                            }
                            finally
                            {
                                Gdi32.SetBkMode(hdc, old_mode);
                                Gdi32.SetTextColor(hdc, old_color); // 恢复文本颜色
                                /*
                                var region = Gdi32.CreateRectRgn(clipRect.Left, clipRect.Top, clipRect.Right, clipRect.Bottom);
                                Gdi32.SelectClipRgn(hdc, region);
                                region.Dispose();
                                */
                            }
                        }
                    }
                    // x_offset += line.PixelWidth;    // pABC.abcA + pABC.abcB + pABC.abcC;
                }
                finally
                {
                    Gdi32.DeleteFont(font_handle);
                }
            }
        }

        static Rectangle AdjustRect(Rectangle block_rect,
    RangeWrapper range,
    bool adjust_left,
    bool adjust_right)
        {
            // clipping 矩形的左右进行微调。避免斜体字的某些笔画伸出去的部分被显示成不同的颜色
            var left_delta = range.pABC.abcA;
            var right_delta = range.pABC.abcC;
            if (adjust_left && left_delta < 0)
            {
                block_rect.X -= -left_delta + 1; // 左侧空白
                block_rect.Width += -left_delta + 1;
            }
            if (adjust_right && right_delta < 0)
            {
                block_rect.Width += -right_delta + 1; // 右侧空白
            }

            return block_rect;
        }


